"""Configure the mod and generate icons for it.

Requirements:
- python -m pip install Pillow click
- npm install -g lua-fmt

Optional:
- pre-commit installed (will be executed if found)
"""
import inspect
import itertools
import os
import pprint
import re
import shutil
import subprocess
import tempfile
from contextlib import AbstractContextManager, contextmanager
from functools import wraps
from inspect import ClosureVars
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, List, Tuple, Union
from zipfile import ZipFile

import attr
import click
import requests
import yaml
from PIL import Image, ImageDraw, ImageFont

#######################################################################################
##                                  Working classes                                  ##
#######################################################################################

STACKING_MOD_NAME = "DeadlockStackingForOmnimatter"


@attr.s(slots=True)
class ModPrototypes:
    """Generate stacked mods prototypes."""

    manifest: "ModManifest" = attr.ib()

    def start_prototypes(self, file):
        """Write the start of a prototype file."""
        self._write_lines(
            file,
            "-- DO NOT MODIFY THIS FILE MANUALLY",
            "-- This file is generated by running the configure script.",
            "local stackables = {}",
            "",
        )

    @contextmanager
    def define(self, file, category: str):
        """Define a stackable category."""
        self._write_lines(
            file,
            f"-- Defined {category}s",
            f"stackables.{category} = {'{'}",
        )

        prototypes = []

        def _define_prototype(prototype):
            prototypes.append(prototype)

        yield _define_prototype

        prototypes[:-1] = map("{},".format, prototypes[:-1])
        self._write_lines(file, *prototypes)

        self._write_lines(file, "}", "")

    def _lua_path(self, *parts):
        return "/".join([f"__{STACKING_MOD_NAME}__", *parts])

    def _lua_repr(self, val: Union[dict, list, int, str]):
        """Format a dict to a lua table."""
        if isinstance(val, (dict, list, tuple)):
            if isinstance(val, dict):
                seq = (
                    "[{k}]={v}".format(
                        k=self._lua_repr(k),
                        v=self._lua_repr(v),
                    )
                    for k, v in val.items()
                )
            else:
                seq = map(self._lua_repr, val)

            return f"{{{','.join(seq)}}}"

        return repr(val)

    def make(self, item_or_fluid):
        """Make prototype and return it as a LUA table representation."""
        if isinstance(item_or_fluid, ModManifest.Item):
            prototype = self.make_item(item_or_fluid)
        elif not isinstance(item_or_fluid, ModManifest.Fluid):
            prototype = {
                "fluid-name": item_or_fluid.name,
            }
        else:
            raise ValueError(
                "Could not recognize type {item_or_fluid.__class__.__name__}"
            )

        return self._lua_repr(prototype)

    def make_item(self, item):
        """Make prototype for an item."""
        return {
            "item-name": item.name,
            "unlock-tier": f"deadlock-stacking-{item.tier}",
            "icon": self._lua_path(
                "graphics",
                "icons",
                self.manifest.mod,
                f"stacked-{item.name}.png",
            ),
            "icon-size": item.icon.size,
            "icon-additions": item.icon.additions,
        }

    def end_prototypes(self, file):
        """Write the start of a prototype file."""
        self._write_lines(file, "return stackables")

    def _write_lines(self, file, *lines):
        """Write line to a file, including the file ending."""
        file.writelines(map("{}\n".format, lines))


ICON_STYLES_COORDS = itertools.combinations_with_replacement((2, 8, 14), 2)
ICON_STYLES_NAMES = {11: "ingot", 51: "ore-pile", 118: "fluid", 96: "dust"}


@attr.s(slots=True)
class ModIconStacker(AbstractContextManager):
    """Make a stacked icon."""

    manifest: "ModManifest" = attr.ib()
    __tempdir: Path = attr.ib(factory=lambda: Path(tempfile.mkdtemp()))

    ICON_STYLES = {
        ICON_STYLES_NAMES.get(k, k): v
        for k, v in enumerate(itertools.permutations(ICON_STYLES_COORDS, 3))
    }

    FACTORIO_API_AUTH = "https://auth.factorio.com/api-login"
    FACTORIO_MOD_INFO = "https://mods.factorio.com/api/mods/{mod}"
    FACTORIO_MOD_DOWNLOAD = "https://mods.factorio.com/{download_url}"

    @classmethod
    def validate_icon_style(cls, obj: Any, attr: attr.Attribute, value: Any):
        """Validate that the given icon style is valid."""
        if value in cls.ICON_STYLES.keys():
            return

        raise ValueError(
            f"{value} is not a valid icon style "
            f"(expected to be one of {cls.ICON_STYLES.keys()})"
        )

    @classmethod
    def filter_icon_styles(cls, *filters):
        """Apply a filter to the available icon styles."""
        filtered_items = filter(
            lambda item: any(f(*item) for f in filters),
            cls.ICON_STYLES.items(),
        )

        for filtered_key, _ in filtered_items:
            cls.ICON_STYLES.pop(filtered_key, False)

    def dowload_source_icons(self, term):
        """Download the icons and return a mapping from filename to paths."""
        if (
            "FACTORIO_USERNAME" not in os.environ
            or "FACTORIO_PASSWORD" not in os.environ
        ):
            raise RuntimeError(
                "Both environnement variables FACTORIO_USERNAME and FACTORIO_PASSWORD "
                "need to be present for building the stacked icons."
            )

        term.echo("- Authenticating to Factorio API")
        auth_response = requests.post(
            ModIconStacker.FACTORIO_API_AUTH,
            data={
                "username": os.environ["FACTORIO_USERNAME"],
                "password": os.environ["FACTORIO_PASSWORD"],
            },
        )
        if auth_response.status_code != 200:
            raise RuntimeError(
                "Invalid combination of FACTORIO_USERNAME/FACTORIO_PASSWORD"
            )
        api_token = auth_response.json()[0]

        term.echo("- Fetching mod information")
        mod_infos = requests.get(
            ModIconStacker.FACTORIO_MOD_INFO.format(mod=self.manifest.mod)
        ).json()

        term.echo("- Downloading last release mod package")
        lastest = mod_infos["releases"][-1]
        release_zip = requests.get(
            ModIconStacker.FACTORIO_MOD_DOWNLOAD.format(
                download_url=lastest["download_url"].lstrip("/")
            ),
            params={"username": os.environ["FACTORIO_USERNAME"], "token": api_token},
        )

        extration_dir = self.__tempdir / self.manifest.mod
        with ZipFile(BytesIO(release_zip.content)) as zipfile:
            term.echo("- Listing files in the package")
            icons_list = [
                f for f in zipfile.namelist() if self.manifest.icons_regex.match(f)
            ]

            term.echo(f"- Extracting {len(icons_list)} potential icons")
            zipfile.extractall(extration_dir, icons_list)

        return {
            icon_path.stem: icon_path for icon_path in extration_dir.rglob("**/*.png")
        }

    def stack_icons(self, extracted_icons: Dict[str, Path]):
        """Find the images that where extracted."""
        for to_stack in self.manifest.items + self.manifest.fluids:
            if to_stack.icon.name not in extracted_icons:
                yield (to_stack, None)
                continue

            stacked_icon = self.stack_icon(
                img_path=extracted_icons[to_stack.icon.name],
                icon=to_stack.icon,
            )
            yield (to_stack, stacked_icon)

    def stack_icon(self, img_path, icon):
        """Stack an icon."""
        input_img = Image.open(img_path)
        width, height = input_img.size

        if input_img.mode != "RGBA":
            raise ValueError(
                f"Unsupported img mode: {input_img.mode}, is expected to be RGBA."
            )
        elif width != height:
            dimension = min(width, height)
            input_img = input_img.crop((0, 0, dimension, dimension))

        input_img = input_img.resize((48, 48), Image.LANCZOS)

        stacked_img = Image.new("RGBA", (64, 64), color=(0, 0, 0, 0))
        for pos in ModIconStacker.ICON_STYLES[icon.style]:
            stacked_img.paste(input_img, pos, input_img)

        return stacked_img

    def make_stylesheet(self, img_path, columns=10):
        """Stack the icon in every possible style."""
        rows, tail = divmod(len(ModIconStacker.ICON_STYLES), columns)
        stylesheet_icons = Image.new(
            "RGBA",
            (
                64 * columns,
                64 * (rows + (1 if tail else 0)),
            ),
            color=(0, 0, 0, 0),
        )
        stylesheet_legend = Image.new(
            "RGBA",
            stylesheet_icons.size,
            color=(0, 0, 0, 0),
        )
        stylesheet_font = ImageFont.load_default()
        stylesheet_draw = ImageDraw.Draw(stylesheet_legend)

        styles_grid = (
            ((i * 64 for i in divmod(i, columns)), style)
            for i, style in enumerate(ModIconStacker.ICON_STYLES.keys())
        )

        for (y, x), style in styles_grid:
            stacked_img = self.stack_icon(
                img_path=img_path,
                icon=ModManifest.Icon("stylesheet", style),
            )
            stylesheet_draw.text(
                (x + 2, y + 2),
                str(style),
                font=stylesheet_font,
                fill=(255, 255, 0, 120),
            )
            stylesheet_icons.paste(
                stacked_img.resize((64, 64), Image.LANCZOS),
                (x, y),
            )

        return Image.alpha_composite(stylesheet_icons, stylesheet_legend)

    def __exit__(self, exc_type, exc_value, traceback):
        """Clear the inside of the temp directory when exiting the context."""
        shutil.rmtree(self.__tempdir)
        return None


@attr.s(slots=True, frozen=True)
class ModManifest:
    """The manifest of how we should stack the mod."""

    @staticmethod
    def load(manifest_path: Path) -> "ModManifest":
        """Load a manifest and convert it ot an instance of ModManifest."""
        with manifest_path.open("r") as manifest_file:
            manifest = yaml.safe_load(manifest_file)

        return ModManifest(
            id=manifest_path.stem,
            mod=manifest["mod"],
            items=[
                ModManifest.Icon.load_iconable(ModManifest.Item, i)
                for i in manifest.get("items", [])
            ],
            fluids=[
                ModManifest.Icon.load_iconable(ModManifest.Fluid, i)
                for i in manifest.get("fluids", [])
            ],
        )

    id: str = attr.ib()
    mod: str = attr.ib()

    items: List["ModManifest.Item"] = attr.ib()
    fluids: List["ModManifest.Fluid"] = attr.ib()

    icons_regex: re = attr.ib(
        default=r"^[^\/.].*icons.*\.png$",
        converter=re.compile,
    )

    @attr.s(slots=True, frozen=True)
    class Icon:
        """A class representing an icon."""

        @staticmethod
        def load_iconable(cls, yaml_obj):
            """Create an object that hold an icon from a yaml fragment."""
            return cls(
                icon=ModManifest.Icon.load(
                    default_icon=yaml_obj["name"],
                    yaml_obj=yaml_obj.pop("icon", None),
                ),
                **yaml_obj,
            )

        @classmethod
        def load(cls, default_icon, yaml_obj):
            """Create icon(s) from a yaml fragment."""
            if not isinstance(yaml_obj, dict):
                yaml_obj = {"style": yaml_obj}

            return cls(
                name=yaml_obj.pop("name", default_icon),
                **yaml_obj,
            )

        name: str = attr.ib()
        style: Union[int, str] = attr.ib(
            default="ingot",
            converter=attr.converters.default_if_none("ingot"),
            validator=ModIconStacker.validate_icon_style,
        )
        size: int = attr.ib(default=64)
        additions: List[Dict] = attr.ib(factory=list)

    @attr.s(slots=True, frozen=True)
    class Item:
        """A simple object to held the information about an item."""

        name: str = attr.ib()
        type: str = attr.ib()
        tier: int = attr.ib()
        icon: "ModManifest.Icon" = attr.ib()

    @attr.s(slots=True, frozen=True)
    class Fluid:
        """A simple object to held the information about a fluid."""

        name: str = attr.ib()
        tier: int = attr.ib()
        icon: "ModManifest.Icon" = attr.ib()


#######################################################################################
##                              Command Line Interface                               ##
#######################################################################################
MOD_PACKAGE_DIR = Path(__file__).parent
MOD_PROTOTYPES_DIR = MOD_PACKAGE_DIR / "prototypes"
MOD_ICONS_DIR = MOD_PACKAGE_DIR / "graphics" / "icons"


@attr.s
class CliTerminal:
    """A wrapper around various term utils to be easier to use."""

    width: int = attr.ib()
    colours: bool = attr.ib()

    framing = attr.ib(
        factory=lambda: {
            "frame": ("═", "║"),
            "corners": ("╔", "╗", "╚", "╝"),
            "inner-corners": ("╠", "╣"),
            "inner-delimiters": ("╡", "╞"),
        }
    )
    session_params: dict = attr.ib(factory=dict)

    @staticmethod
    def term_session(func):
        """Decorate a method to be session sensitive."""
        acceptable_params = set(inspect.signature(func).parameters.keys())
        if "style" in acceptable_params:
            acceptable_params |= {"fg", "bg"}

        @wraps(func)
        def term_sensitive_func(self, *args, **kwargs):
            kwargs.update(
                {
                    k: v
                    for k, v in self.session_params.items()
                    if k in acceptable_params and k not in kwargs
                }
            )
            return func(self, *args, **kwargs)

        return term_sensitive_func

    @contextmanager
    def frame(self, title, **style):
        """Create a framed section."""
        self.echo("", framed=self.framing["corners"][:2], separator=True, **style)
        with self._session(framed=True, **style):
            self.echo(title, alignment="center")
            self.echo("", separator=True)
            yield
        self.echo("", framed=self.framing["corners"][2:], separator=True, **style)

    @contextmanager
    def _session(self, new=False, **session_params):
        """Change printing parameters until the end of the contextmanager."""
        previous_state = dict(**self.session_params)
        if new:
            self.session_params = session_params
        else:
            self.session_params.update(session_params)
        yield
        self.session_params = previous_state

    @term_session.__func__
    def echo(self, text, framed=False, separator=False, alignment="left", **style):
        """Simply take echo to the terminal, ignore style if self.colours is False."""
        text = self._format_text(
            text,
            width=self.width,
            framed=framed,
            separator=separator,
            alignment=alignment,
        )

        if self.colours:
            text = click.style(text, **style)
        click.echo(text)

    def delimiter(self, title="", **style):
        """Make a simple section delimiter."""
        self.echo(title, separator=True, alignment="center", **style)

    def _format_text(
        self,
        text: str,
        width: int,
        alignment: str,
        framed: Union[Tuple[str], bool] = False,
        separator: bool = False,
    ):
        """Froamt and align text for better printing, including framing and padding."""
        alignment = {"left": "<", "center": "^", "right": ">"}.get(alignment, "")

        if framed is True:
            framing = 2 * [self.framing["frame"][1]]
        elif framed:
            framing = framed
        else:
            framing = 2 * [""]

        if len(text):
            text = f" {text} "

        if separator is True:
            if len(text):
                text = text.join(self.framing["inner-delimiters"])
            if framed is True:
                framing = self.framing["inner-corners"]
            filling_char = self.framing["frame"][0]
        else:
            filling_char = ""

        width -= len("".join(framing))
        text = f"{{text:{filling_char}{alignment}{width}}}".format(text=text)

        text = text.join(framing)

        return text

    def shell_exec(self, title, *commands, abort_if_error=False):
        """Execute a command in a sub-shell."""
        self.echo("", framed=self.framing["corners"][:2], separator=True)
        self.echo(title, framed=True, alignment="center")
        self.echo("", framed=self.framing["corners"][2:], separator=True)

        result = subprocess.call(";".join(commands), shell=True)
        if result != 0:
            self.delimiter(
                f"Error {result}",
                fg="red" if abort_if_error else "yellow",
            )
            if abort_if_error is True:
                raise click.Abort

        return result


@click.group()
@click.pass_context
def cli(ctx):
    """Command Line Interface for generating stacked icon mod."""
    ctx.obj = CliTerminal(width=80, colours=True)


@cli.command("preview")
@click.argument("icon", type=click.Path(exists=True, dir_okay=False, readable=True))
@click.pass_obj
def cli_preview(term: CliTerminal, icon):
    """Preview all style for a given icon."""
    icon_stacker = ModIconStacker(None)
    stylesheet = icon_stacker.make_stylesheet(icon)
    stylesheet.save(Path(icon).stem + "-styles.png")


@cli.command("build")
@click.pass_obj
def cli_build(term: CliTerminal):
    """Build all needed files for declared mod."""
    click.clear()
    for old_prototype in MOD_PROTOTYPES_DIR.glob("*.lua"):
        old_prototype.unlink()

    for manifest_path in MOD_PROTOTYPES_DIR.glob("*.yml"):
        with term.frame(f"Building for mod: {manifest_path.stem}"):
            manifest = ModManifest.load(manifest_path=manifest_path)
            term.echo("- Loaded manifest")

            term.delimiter("Building LUA files")
            prototypes = ModPrototypes(manifest)
            term.echo("- Building prototypes")
            with (MOD_PROTOTYPES_DIR / f"{manifest.mod}.lua").open("w") as file:
                prototypes.start_prototypes(file)

                with prototypes.define(file, "items") as define_prototype:
                    for item in manifest.items:
                        define_prototype(prototypes.make(item))
                term.echo(f"- Registered {len(manifest.items)} items")

                with prototypes.define(file, "fluids") as define_prototype:
                    for fluid in manifest.fluids:
                        define_prototype(prototypes.make(fluid))
                term.echo(f"- Registered {len(manifest.fluids)} fluids")

                prototypes.end_prototypes(file)

            term.delimiter("Building stacked icons")
            with ModIconStacker(manifest) as icon_stacker:
                source_icons = icon_stacker.dowload_source_icons(term)

                term.echo(f"- Stacking icons")
                for stacked_info, icon in icon_stacker.stack_icons(source_icons):
                    if icon is None:
                        term.echo(
                            "  - Could not find a suitable icon for: "
                            f"{stacked_info.name}, other icons:",
                            fg="yellow",
                        )
                        for i in sorted(source_icons.keys()):
                            term.echo(f"    - {i}", fg="yellow")
                        continue

                    term.echo(f"  - Stacked icon {stacked_info.name}")
                    (MOD_ICONS_DIR / manifest.mod).mkdir(exist_ok=True)
                    icon.save(
                        MOD_ICONS_DIR
                        / manifest.mod
                        / f"stacked-{stacked_info.name}.png"
                    )

                saved_icons = list((MOD_ICONS_DIR / manifest.mod).glob("*.png"))
                term.echo(f"- Stacked {len(saved_icons)} icons")
    term.shell_exec(
        "Formatting generated LUA files",
        *[
            f"luafmt --verbose --write-mode replace {lua_file} && "
            f"echo Formated {lua_file.name}"
            for lua_file in MOD_PROTOTYPES_DIR.glob("*.lua")
        ],
        abort_if_error=True,
    )
    term.shell_exec(
        "Running `pre-commit`",
        "pre-commit run --hook-stage manual --all",
    )


if __name__ == "__main__":
    cli()

    for manifest_path in (Path(__file__).parent / "prototypes").glob("*.yml"):
        pprint.pprint(ModManifest.load(manifest_path=manifest_path))
